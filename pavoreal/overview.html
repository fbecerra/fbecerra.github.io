<!DOCTYPE html>
<html lang="en">
<head>
<title>About</title>
<meta charset="utf-8">
<link rel="shortcut icon" href="images/pavoreal.ico">
<link rel="stylesheet" href="css/reset.css" type="text/css" media="all">
<link rel="stylesheet" href="css/layout.css" type="text/css" media="all">
<link rel="stylesheet" href="css/style.css" type="text/css" media="all">
<link rel="stylesheet" href="css/zerogrid.css">
<link rel="stylesheet" href="css/responsive.css">
<script type="text/javascript" src="js/jquery-1.6.js" ></script>
<script type="text/javascript" src="js/cufon-yui.js"></script>
<script type="text/javascript" src="js/cufon-replace.js"></script>
<script type="text/javascript" src="js/Swis721_Cn_BT_400.font.js"></script>
<script type="text/javascript" src="js/Swis721_Cn_BT_700.font.js"></script>
<script type="text/javascript" src="js/tabs.js"></script>
<script src="js/css3-mediaqueries.js"></script>
  <!--[if lt IE 9]>
  	<script type="text/javascript" src="js/html5.js"></script>
	<style type="text/css">
		.bg{ behavior: url(js/PIE.htc); }
	</style>
  <![endif]-->
	<!--[if lt IE 7]>
		<div style=' clear: both; text-align:center; position: relative;'>
			<a href="http://www.microsoft.com/windows/internet-explorer/default.aspx?ocid=ie6_countdown_bannercode"><img src="http://www.theie6countdown.com/images/upgrade.jpg" border="0"  alt="" /></a>
		</div>
	<![endif]-->

</head>

<body id="page3">
	<div class="body1">
	<div class="body2">
	<div class="body5">
		<div class="main zerogrid">
<!-- header -->
			<header>
				<div class="wrapper rÆ¡w">
				<h1><a href="index.html" id="logo"><img src="images/logo.png" /></a></h1>
				<nav>
					<ul id="menu">
                                                <li id="nav1" class="active"><a href="overview.html">Overview</a></li>
                                                <li id="nav2"><a href="algorithm.html">Algorithm</a></li>
                                                <li id="nav3"><a href="analysis.html">Analysis</a></li>
                                                <li id="nav4"><a href="gallery.html">Gallery</a></li>
                                                <li id="nav5"><a href="download.html">Download</a></li>
					</ul>
				</nav>
				</div>
			</header>
<!-- header end-->
		</div>
	</div>
	</div>
	</div>
	<div class="body3">
		<div class="main zerogrid">
<!-- content -->
			<article id="content">
				<div class="wrapper">
					<div class="wrap-col">
						<section class="col-3-4">
						<h2 class="under"><a name="motivation">Motivation</a></h2>
						<h7><p align="justify">We are three second-year graduate students in the astronomy department. 
							For our research, we perform simulations with massively parallel codes (e.g. moving mesh fluid dynamics code
							<a href="http://www.cfa.harvard.edu/itc/research/movingmeshcosmology/"><font color="63A3F7">Arepo</font></a>
							and particle-in-cell code <a href="http://tristan-mp.wikispaces.com/"><font color="63A3F7">tristan-mp</font></a>)
							to study various astrophysical systems.</p>
							
							<p align="justify">Efficient analysis and visualization of the simulation data is crucial to our work.
							With 3D simulations, visualizing the data is a challenge even when the 
							simulation box has evenly-spaced grid points, simply because the screen is 2D. 
							One common simplification technique is to just plot a couple of 2D slices 
							through the 3D box, which inevitably misses a lot of structures in the simulation.
							A further challenge arises when the simulation grid is not uniform, which is 
							the case for many cosmological simulations, including simulations generated by 
							<a href="http://www.cfa.harvard.edu/itc/research/movingmeshcosmology/"><font color="63A3F7">Arepo</font></a>.<br></p>
							
							<p align="justify">A lot of recent effort in the community has gone into developing 
							volume-rendering software to visualize the full 3D volumetric data sets.
							In particular, <a href="http://yt-project.org/"><font color="00A329">yt</font></a> 
							is a widely used, open source software, 
							primarily written in Python with MPI, for this purpose. 
							However, it lacks GPU support, which could potentially speedup and increase the efficiency of the algorithm.</p>
							
							<p align="justify">In addition, <a href="http://yt-project.org/"><font color="00A329">yt</font></a> 		
							 and other visualization software only support output files from limited number of simulation 
							codes and data structures, which unfortunately does not include our codes. <br></p>
							
							<p align="justify">For our final project, we developed an algorithm which combines GPU with MPI
							to render 3D data of arbitrary grid type at lightning fast speed.</p>

							<p align="justify">We would like to visualize 3D scalar fields that are large data set outputs of simulations for both structured and unstructured grids. 
                The goal is to create a rapid method to render the whole 3D data using raycasting with GPUs and MPI so that we can visualize the outputs of simulations we use in our research projects.</p>
						</h7>
						</section>
					</div>

                                        <section class="col-1-4">
                                                <div class="wrap-col">
                                                        <h3>Overview</h3>
                                                        <ul class="list1">
                                                                <li><a href="#motivation">Motivation</a></li>
                                                                <li><a href="#design">Program Deisgn</a></li>
                                                                <li><a href="#usage">Usage</a></li>
                                                                <li><a href="#performance">Performance</a></li>
                                                                <li><a href="#optimization">Optimization</a></li>
                                                                <li><a href="#insights">Insights</a></li>
                                                                <li><a href="#future">Future Work</a></li>
                                                                <li><a href="#reflections">Reflections</a></li>
                                                        </ul>
                                                </div>
                                                </section>
                                        <section class="col-3-4">
				</div>
				<div class="wrapper">
                                        <section class="col-3-4">
                                        <h2 class="under"><a name="data">Our Data</a></h2>
                                        <div class="wrapper">
						<h7>
						<p align="justify">The data comes from astrophysical fluid dynamics simulations used in our research. 
						These simulations are run with a veriety of codes, including the moving mesh code Arepo and the particle-in-cell code tristan-mp. 
						As mentioned above, both codes produces different kind of outputs.
						In the case of Arepo, the data is an unstructured Voronoi mesh, while tristan-mp generates structured data.
						The file size of the outputs depend strongly on the size of the grid/mesh, and on the resolution employed in the simulations, ranging from a few MB up to a few GB.</p>
                                                </h7>
                                        </div>
                                        </section>
				</div>
                                <div class="wrapper">
                                        <section class="col-3-4">
                                        <h2 class="under"><a name="design">Program Design</a></h2>
                                        <div class="wrapper">
						<h7>
						<p align="justify">Raycasting is highly parallelizable, so we use GPUs to have each thread calculate a single picture in our image. 
                In addition, we choose to further boost our method by using MPI to distribute the calculation of different frames in the movie across a GPU cluster. 
                This is the most efficient way to use a cluster for generating movies, as the frame calculations are independent of each other and the algorithm strongly scales.
                Our code, Pavoreal, can be run by importing the pavoreal package and writing a simple and short driver script and setting up a configuration file, making it easy to use for
                a variety of applications.</p>
                                                </h7>
                                        </div>
                                        </section>
                                </div>
                                <div class="wrapper">
                                        <section class="col-3-4">
                                        <h2 class="under"><a name="usage">Usage</a></h2>
                                        <div class="wrapper">
						<h7>
						<p align="justify">The code is used by setting up a configuration file which specifies the camera path/orientation, transfer functions, data, output directory, 
                and gridding/smoothing parameters and importing the pavoreal package and running a simple driver script (see README or the <a href="download.html">download</a> page for details and examples).</p>
                                                </h7>
                                        </div>
                                        </section>
                                </div>
                                <div class="wrapper">
                                        <section class="col-3-4">
                                        <h2 class="under"><a name="performance">Performance</a></h2>
                                        <div class="wrapper">
						<h7>
						<p align="justify">The MPI version of our code scales strongly, since there is no communication between processes. Using a GPU, as opposed to a CPU, on each process has significant
                advantages, making the total runtime of the code 100-1000 times faster for the various data sets. Some optimizations we implemented include: 
						<li>Rewriting all the kernels as a single kernel, which uses less memory and makes the algorithm more computationally dominated</li>
						<li>Casting the 3D data as a texture. This increased our speed by over an order of magnitude</li> 
                				<li>Making sure all reads are coalesced</li>
						<li>Casting the transfer function as a texture for rapid lookup. This increased the speed by a factor of 1.4</li>
				                <li>Writing a cubic spline interpolated as a weighted sum of 8 trilinear texture lookups rather than using a full 64 point stencil.</p>
                                                </h7>
                                        </div>
                                        </section>
                                </div>
                                <div class="wrapper">
                                        <section class="col-3-4">
                                        <h2 class="under"><a name="optimization">Optimization</a></h2>
                                        <div class="wrapper">
						<h7>
						<p align="justify">
						<li>Cast 3D data to texture</li>
						<li>Cast transfer function to texture</li>
            <li>Cubic spline calculated with 8-pt weighted stencil texture lookup rather than 64-pt stencil</li>
            <li>Coalesced memory reads, massively parallel texture lookups in <a href="./algorithm.html#Approach1">Approach 1</a> </li>
            <li>Combined kernel, computation dominated, in <a href="./algorithm.html#Approach2">Approach 2</a> (5x faster than Approach 1)</li></p>
                                                </h7>
                                        </div>
                                        </section>
                                </div>
                                <div class="wrapper">
                                        <section class="col-3-4">
                                        <h2 class="under"><a name="insights">Insights</a></h2>
                                        <div class="wrapper">
                                                <h7>
						<p align="justify"><li>We learned a variety of insights from this project. We saw that textures can be used in more general ways besides a simple lookup. 
                We can construct a cubic spline lookup by using a stencil of 8 texture lookups.</li>
						<li>We learned that method is inexpensive and a good way to get smoother quality images.</li>
                Additionally, we can cast the transfer function as a texture (which also makes sampling it smoother than just using a fixed number of bins) to further optimize our code.
                				<li>While writing our code we also learned that we have to manually deallocate memory on the GPU in PyCUDA once it is no longer being used, otherwise the available memory might not be enough.</li></p>
                                                </h7>
                                        </div>
                                        </section>
                                </div>
                                <div class="wrapper">
                                        <section class="col-3-4">
                                        <h2 class="under"><a name="future">Future Work</a></h2>
                                        <div class="wrapper">
                                                <h7>
						<p align="justify">We would like to extend this project by using PyOpenGL, or the GL module included in PyCUDA, to create an interactive version of pavoreal by having the GPU memory feed directly into video output.
                Unfortunately, PyCUDA was compiled without GL support on resonance, so our current method generates images for every frame (with matplotlib) and movies on the CPU. The data transfer between GPU and CPU, and the file writing actually takes a significant amount of time (on order of a second per frame) compared to the rendering calculations, 
                so the interactive mode would also help visualize data even faster.</p>

                                                </h7>
                                        </div>
                                        </section>
                                </div>
                                <div class="wrapper">
                                        <section class="col-3-4">
                                        <h2 class="under"><a name="reflections">Reflections</a></h2>
                                        <div class="wrapper">
                                                <h7>
						<p align="justify">We definitely enjoyed harnessing the raw power of GPUs and also viewing the final movies we created, which were a nice reward. 
                Some of the simulations have never been visualized before and it was exciting to see what they looked like. One of the challenging aspects of the project was dealing with the unstructured
                data sets. Binning data on GPUs is not straightforward since naive CPU-like implementations can lead to bank conflicts. 
                Working out the geometry of the camera grid was frustrating, especially after we changed the data to be cast to a texture because initially we fixed the camera and rotated the object, 
                but textures cannot be rotated so we have to rotate the camera instead and rework all the code and conventions.</p>

                                                </h7>
                                        </div>
                                        </section>

				</div>

			</article>
		</div>
	</div>
	<div class="body4">
		<div class="main zerogrid">
			<article id="content2">
				<div class="wrapper row">
                                        <section class="col-1-2">
                                        <div class="wrap-col">
                                                <h4>Team members</h4>
                                                <ul class="list1">
                                                        <li><a href="https://www.cfa.harvard.edu/~fbecerra">Fernando Becerra</a></li>
                                                        <li><a href="#">Xinyi Guo</a></li>
                                                        <li><a href="https://www.cfa.harvard.edu/~pmocz/">Philip Mocz</a></li>
                                                </ul>
                                        </div>
                                        </section>
                                        <section class="col-1-2">
                                        <div class="wrap-col">
                                                <h4>Affiliation</h4>
                                                <ul class="address">
                                                        <li>Harvard-Smithsonian Center for Astrophysics</li>
                                                        <li>60 Garden Street, Cambridge, MA, USA</li>
                                                </ul>
                                        </div>
                                        </section>
				</div>
			</article>
<!-- content end -->
		</div>
	</div>
		<div class="main zerogrid">
<!-- footer -->
			<footer>
				<a href="http://www.zerotheme.com/432/free-responsive-html5-css3-website-templates.html" target="_blank">Html5 Templates</a> by <a href="http://www.templatemonster.com/" target="_blank">Templatesmonster.com</a> - 
				<a href="http://www.zerotheme.com/432/free-responsive-html5-css3-website-templates.html" target="_blank">Responsive Themes</a> by <a href="http://www.zerotheme.com/" target="_blank">Zerotheme.com</a>
			</footer>
<!-- footer end -->
		</div>
<script type="text/javascript"> Cufon.now(); </script>
<script>
	$(document).ready(function() {
		tabs.init();
	})
</script>
</body>
</html>
